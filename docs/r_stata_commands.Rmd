---
title: "R and Stata Equivalencies"
author: "Chuck Lanfear"
date: "Updated `r stringr::str_replace(format(Sys.time(), '%I:%M %p, %B %d, %Y'), '^0','')`"
output: html_document
---

<style>
.column-left{
  float: left;
  width: 48%;
  text-align: left;
}
.column-right{
  float: right;
  width: 48%;
  text-align: left;
}
.column-center{
  float: right;
  width: 100%;
  text-align: left;
}
</style>


This document depicts both Stata and R approaches to data management, modeling, and plotting seen in SOC505. They are presented side-by-side to make it easier to move between platforms. It also demonstrates that Stata and R are quite similar in syntax in many cases. R often takes more code to do common tasks than Stata, but can do many things that are not possible in Stata. Both are excellent platforms for quantitative research, though Stata is more common in economics and R is more common in statistics and data science.

<div class="column-center">

## Loading Data

Provided a Stata data set (`.dta` file), we can read it into either Stata or R. 
</div>
<div class="column-left">
#### Stata

Stata can only load one data set at a time, so it does not get assigned to an object.

```
use example_data.dta
```

This will load from Stata's current working directory. You can change the working directory using `cd "path"` (e.g. `cd "C:\Users\me\documents"`).
</div>
<div class="column-right">
#### R

R can load an arbitrary number of data sets at once, so they must each be assigned a name. I recommend `read_dta()` in the `haven` package--part of the `tidyverse`--for loading Stata files because it preserves Stata labels.

```
example_data <- haven::read_dta("example_data.dta")
```

R will load this file from your current working directory. If using a .Rmd file, this will default to the directory the .Rmd file is in. You can change the working directory with `setwd("path")` (e.g. `setwd("C:\Users\me\documents")`).
</div>

<div class="column-center">
## Creating Example Data

For the first homework, we created a sample of simulated data with a specified covariance matrix and means.
</div>
<div class="column-left">
#### Stata
```
matrix mean_vec=(1.0, 2.0, 3.0)
matrix cov_mat=(1.0, .75, 1.0  \ /// 
                .75, 1.5, 0.0  \ ///  
                1.0, 0.0, 2.0)            
corr2data x y z, n(300) mean(mean_vec) ///
   cov(cov_mat) cstorage(full) seed(341305)
```
In Stata we create a vector of means (named `m` here) and a matrix of covariances (named `vc`). `corr2data` then generates data with variables named `x`, `y`, and `z` whose means (`mean(m)`) and covariances (`cov(vc)`) match what we provided. We specify the sample size with `n()`.
</div>

<div class="column-right">
#### R
```
mean_vec <- c("x" = 1.0, "y" = 2.0, "z" = 3.0)
cov_mat <- rbind(c(1.0, .75, 1.0),
                 c(.75, 1.5, 0.0),
                 c(1.0, 0.0, 2.0))
example_data <- data.frame(MASS::mvrnorm(300,
                            mu = mean_vec, 
                            Sigma = cov_mat,
                            empirical = TRUE))
```
In R, the operation is similar to Stata. We provide a vector of means (`mean_vec`) and a covariance matrix (`cov_mat`). Note we create vectors with `c()` and combined them into a matrix by rows with `rbind()` (row bind). `mvrnorm()` in the `MASS` has number of observations (`300`) as its first argument. `::` allows us to use a function from a package without loading the whole package.
</div>

<div class="column-center">
## Creating Variables

R and Stata are very different with regard to storing, accessing, and modifying data and variables. Stata only loads one data set at a time. R stores all object including data as objects and can have an arbitrary number loaded at once. Below I create an interaction term between `x` and `z` and a discrete version of `x`.
</div>

<div class="column-left">
#### Stata
In Stata, we just use `generate` and the variable is created in our current data.
```
generate x_z = x * z
generate x_disc = 0
replace x_disc = 1 if x < .5
replace x_disc = 2 if x > .5 & x < 1.5
replace x_disc = 3 if x > 1.5
```
</div>

<div class="column-right">
#### R

In R, we assign variables inside the data we want to use. We can do this with base R:
```
example_data$x_z <- example_data$x * example_data$z
example_data$x_disc <- 
  ifelse(example_data$x < .5, 1, 
    ifelse(example_data$x > .5 & example_data$x < 1.5, 2,
      ifelse(example_data$x > 1.5, 3, 0)))
```
Note here I chained three `ifelse()` statements together in one call. This is complex, but powerful.

Or we can use the `dplyr` package:
```
example_data <- example_data %>% mutate(x_z = x * z)
example_data <- example_data %>% 
  mutate(x_disc =
    case_when(
      x < .5 ~ 1,
      x > .5 & x < 1.5 ~ 2,
      x > 1.5 ~ 3
    ))
```
`case_when()` does seuqential `ifelse()` statements but is much more readable.
</div>

<div class="column-center">
## Linear Models

Modeling commands are very similar between R and Stata. The primary difference is that R argument go inside paranthesis rather than just after the name of the command as in Stata. Stata options come after a comma and are separate from formulae, but all R arguments--including formulae--are treated the same and separated by commas. Default R output is simpler than Stata: use `summary()` if you want Stata-like output. In Stata, you save model output using `estimates store` while in R you just assign the model object to a name. Note we specified which data we are using in R: R can have many data sets loaded at the same time!
</div>

<div class="column-left">
#### Stata

```
glm y x z, ///
   family(gaussian) link(identity)
estimates store example_model
```
Note in the above examples, a single Stata command can be spread over multiple lines using `///`.
</div>

<div class="column-right">
#### R

```
example_model <- glm(y ~ x + z,
                     family = gaussian(link = "identity"),
                     data = example_data)
summary(example_model)
```
 In R, all commands can span multiple lines so long as each line (other than the last) ends in an operator (e.g. `,` as above, but also `+` like in `ggplot2` calls).
</div>

<div class="column-center">



## Linear Hypotheses

Linear hypotheses are used to test restrictions on models (e.g. that a coefficient is zero or equal to another).
</div>

<div class="column-left">
#### Stata

```
test x=0
test x=z
test x=z=0
```
Like most postestimation commands in Stata, linear hypotheses (with `test`) must be conducted immediately after running the model of interest. 
</div>

<div class="column-right">
#### R

```
car::linearHypothesis(example_model, "x=0")
car::linearHypothesis(example_model, "x=z")
car::linearHypothesis(example_model, c("x=0", "z=0"))
```
In R, they must be run using a saved model object (like `example_model` created above). In R, the `linearHypothesis()` function is found in the `car` package. You can obtain this package using `install.packages("car")`. You can then either use `library(car)` to load the package or run `linearHypothesis()` from car directly--without loading the package--using `car::linearHypothesis()` as below.
</div>

<div class="column-center">
## Residuals

We often want to obtain residuals to check model fit or produce plots where we have controlled for covariates.  
</div>

<div class="column-left">
#### Stata

```
predict residual_y_xz, deviance // GLM uses deviance 
predict residual_y_xz, residual // OLS uses residual
```
Obtaining residuals is a postestimation command in Stata, which must be run immediately after a model.
</div>

<div class="column-right">
#### R

```
residual_y_xz <- residuals(example_model)
example_data$residual_y_xz <- residuals(example_model)
```
In R, we run the command on a saved model object. If you want to save the residuals to the original data, you can just assign them as a column.
</div>



<div class="column-center">
## Dummy Variables

Dummy variables can be prepared for models in two ways: Creating individual dummy variables or specifying them in the model formula. I prefer to store categorical data as factors or strings (character data). This way you don't confuse them with numeric variables.

### Dummies in Formula

We can specify dummies directly in the formula in either Stat or R.
</div>

<div class="column-left">
#### Stata
In Stata, we just use append our categorical variable with `i.`:
```
glm y i.x_disc 
```
</div>

<div class="column-right">
#### R

In R, variables stored as factors automatically turn into dummies:

```
glm(y ~ factor(x_disc), data=example_data)
```

Note if you assigned it as a factor when you created or loaded the data, you don't need to specify it as a factor in the formula.
</div>

<div class="column-center">
### Dummies in Data

We can also manually create dummies in the actual data (Jerry's preference)
</div>

<div class="column-left">
#### Stata

We can either generate each dummy individually or use a `tabulate` shortcut.

```
generate x_d1 = 0
replace x_d1 = 1 if x_disc==1
generate x_d2 = 0
replace x_d2 = 2 if x_disc==2
generate x_d3 = 0
replace x_d3 = 3 if x_disc==3

tabulate x_disc, generate(x_d)
```
</div>

<div class="column-right">
#### R

Base R:
```
example_data$x_d1 <- ifelse(example_data$x_disc==1, 1, 0)
example_data$x_d2 <- ifelse(example_data$x_disc==2, 1, 0)
example_data$x_d3 <- ifelse(example_data$x_disc==3, 1, 0)
```

`dplyr`:
```
example_data <- example_data %>%
  mutate(x_d1 = ifelse(x_disc==1, 1, 0),
         x_d2 = ifelse(x_disc==2, 2, 0),
         x_d3 = ifelse(x_disc==3, 3, 0))
```
</div>

<div class="column-center">
## Tables

</div>

<div class="column-left">
#### Stata


```
tab x_disc
tab x_d1 x_d2
```

</div>
<div class="column-right">
#### R

Base R:
```
table(example_data$x_disc)
table(example_data$x_d1, example_data$x_d2)

```

`dplyr`:
```
example_data %>% count(x_disc)
example_data %>% count(x_d1, x_d2)
```
</div>

<div class="column-center">
## Logit Models

Logistic regression is a generalized linear model for binomially distributed data which uses a logit function link.

</div>

<div class="column-left">
#### Stata

Stata offers multiple commands for running a logistic regression. `glm` and `logit` report log-odds coefficients while `logistic` reports odds ratios. `logit` is just a shortcut for `glm` to save typing out the family and link.
```
glm x_d1 y z, family(binomial) link(logit)
logit x_d1 y z
logistic x_d1 y z

```
</div>

<div class="column-right">
#### R

R uses `glm()` for logistic regression.
```
example_model2 <- 
  glm(x_d1 ~ y + z,
      family = binomial(link = "logit"),
      data = example_data)
summary(example_model2)
```

To obtain odds ratios, exponentiate the log-odds coefficients and/or their confidence intervals:
```
exp(coef(example_model2))
exp(confint(example_model2))
```
</div>



<div class="column-center">
# Plotting

## Scatterplots

</div>

<div class="column-left">
#### Stata

```
scatter y x
```

</div>
<div class="column-right">
#### R

Base R scatterplots use `plot()` and can take either a formula or `x` and `y` arguments:
```
plot(example_data$y ~ example_data$x)
plot(example_data$x, example_data$y, data=example_data)
```

`gplot2` uses `geom_point()`:

```
ggplot(example_data, aes(x, y)) + 
  geom_point()
```
</div>

<div class="column-center">
### Fit Lines on Scatterplots

Often we want to plot regression lines on our scatterplots.
</div>

<div class="column-left">
#### Stata

We can just draw both the scatter and a linear fit (`lfit`) at the same time:
```
graph twoway ((scatter y x) || (lfit y x))
```

</div>
<div class="column-right">
#### R

In base R, we draw the scatterplot and add a linear line (`abline()`):
```
plot(example_data$y ~ example_data$x)
abline(reg=glm(y ~ x, data = example_data))
```

`gplot2` adds a line with `geom_smooth()`:
```
ggplot(example_data, aes(x, y)) + 
  geom_point() + 
  geom_smooth(method="glm", formula= y ~ x)
```

By default `geom_smooth()` includes a 95% confidence interval around the line.
</div>

<div class="column-center">
### Quadratic Lines on Scatterplots

We may want to put a nonlinear fit line on our plot. This is easy in both Stata and R.
</div>

<div class="column-left">
#### Stata

`qfit` generates a quadratic fit line.

```
graph twoway ((scatter y x) || (qfit y x))
```

</div>
<div class="column-right">
#### R

Quadratic fits are slightly awkward in base R:
```
plot(example_data$y ~ example_data$x)
curve(predict(glm(y~x, data=example_data), 
  newdata=data.frame(wt=x)), add=T)
```

They use the same syntax as linear fits in `gplot2`:
```
ggplot(example_data, aes(x, y)) + 
  geom_point() + 
  geom_smooth(method="glm", formula= y ~ poly(x,2))
```
</div>

<div class="column-center">
## Predicted Values

</div>


<div class="column-left">
#### Stata
You can generate predictions as a new variable in your data:
```
predict xb pr_vals
```
Or get predictions at set values:
```
prvalue , x(y=1 z=2)
prvalue , x(y=10 z=-1)
```

</div>
<div class="column-right">
#### R

R uses the `predict()` function to generate predicted values. 
```
predict(example_model2)
```
If you want to predict an outcome at specific values of a variable, you need to provide new data. The new data must have a value for every variable on the right hand side of the model. It accepts multiple rows to produce multiple predictions as well.
```
predict(example_model2, 
        newdata=data.frame(y=1, z=2), 
        type="response")
predict(example_model2, 
        newdata=
          data.frame(y=rep(1,10), 
                     z=seq(-1,1, length.out=10)),
        type="response")
```
</div>

<div class="column-center">
## Plotting Predictions

</div>


<div class="column-left">
#### Stata

Plotting predictions from a model at varying levels of two variables requires multiple `prgen` calls:
```
logit x_d1 y z
prgen y,from(0) to(8) generate(predval_a) n(30) x(z=-1)
prgen y,from(0) to(8) generate(predval_b) n(30) x(z=0)
prgen y,from(0) to(8) generate(predval_c) n(30) x(z=1)

graph twoway (line predval_ap1 predval_ax  || line predval_bp1 predval_bx || line predval_cp1 predval_cx )
```
</div>
<div class="column-right">
#### R

`ggplot2` is well suited to making complex predicted value plots. Here we generate a range of `y` values from 0 to 8 in increments of 0.25. We do this for *each* value of z: -1, 0, and 1.
```
pr_data <- data.frame(y = rep(seq(0,8,0.25), each=3),
                      z = c(-1,0,1))
pr_data$predicted <- 
   predict(example_model2, newdata = pr_data,
   type = "response")
ggplot(pr_data, aes(y=predicted, x=y, group=z, col=z)) + 
   geom_line()
```

`ggeffects` streamlines this process by automatically generating the data and predictions:
```
library(ggeffects)
example_model2 %>% 
   ggpredict(terms=c("y [n=20]","z")) %>% 
   plot()
```
The `n=20` in terms forces `ggpredict()` to generate 20 values of `y`: this makes the lines smoother curves.
</div>